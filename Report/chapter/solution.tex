\chapter{Solution}
This chapter will explain and discuss the chosen solution for implementing the system described in chapter \ref{chp:intro}

\section{Discussion of architecture decisions}
The architecture is based on the publish/subscribe pattern. As shown in figure \ref{fig:basicArc} the dealer and players are decoupled with a publish/subscribe server. This decouples the clients and server in both time, space and flow. By decoupling in space the participants do not need to know each and it is therefore easier to replace a client or server implementation. Decoupling clients and servers in flow will ensure that they do not block each other. Decoupling time will ensure that the participants do not need to be online at the same time. It is relevant to note that the time decoupling is difficult in a game scenario as multiple players will be forced to wait for a client. A specific game relevant time decoupling is therefore implemented in this solution.

\myFigure{basicArc}{System Architecture}{fig:basicArc}{0.8}

The publish/subscribe pattern will in this solution be implemented as topic-based. This approach allows the possibility of easily dividing different blackjack tables in different topics. The topics will in this project use URL like strings.

Other patterns could also have been used in the solution. For example the Acceptor/Connector pattern could have been used for decoupling initialization of connection and the concrete service handling. This would have ensured that a new initialization strategy could easilere have been implemented as it would have been decoupled from the actual processing. Also the leader/follower pattern could have been implemented to execute each publish message but a simple ThreadPool which works similar to the leader/follower pattern is chosen for programming simplicity. Other patterns could therefore have been used and the overall design would have benefited from it.

This solution is though focused on the publish/subscribe pattern to drive the architecture and ensure a high degree of decoupling in both time, flow and space. 

\section{Deployment diagram}
The dealer, publish/subscribe server and players will all be deployed on different hosts. The different entities will then communicate through an UDP socket using topic-based messages. The player and dealer will subscribe to specific topics through the publish/subscribe server.

\myFigure{Deployment}{Deployment diagram }{fig:deploy}{1}

UDP is chosen as transport protocol because it is connectionless and faster than TCP. Also it allows for simple multicasting as multiple connection does not need to be setup up for each message being sent.

\section{Design and implementation}
The software is divided into four different projects: Dealer, Player, PubSubServer and Shared. The Shared project contains classes used by both the Dealer and Player. By using a shared project no code is copied and the game logic and publish/subscribe mechanism needed by both Player and Dealer can be placed in this project.

\section{Design and implementation of the Publish/Subscribe server}
In addition to describing the Client and server a small description of the publish/subscribe server is added. The publish subscribe server ensures a lower decoupling between clients and server.

\myFigure{PubSub_class}{Publish/subscribe server class diagram }{fig:pubSub_class}{1}

In figure \ref{fig:pubSub_class} the structure is shown. It consists of a PublisherService, a SubscriberService and a Filter class. The PublisherService listens for Publishers that wants to publish messages. When a message is received it checks whether its a publish message, and if it is it publishes the message subscribes based on the topic. If the message is not a publish message it is discarded by the PublisherService

Message about clients who wants to subscribe or unsubscribe are handled by the SubscriberService that are listening for these types of messages and handling them. It will add  or remove subscribers to a dictionary. This dictionary is handled by the Filter class.

The Filter class provides an implementation of the dictionary that holds the subscribers endpoint and which topics they are interested in. Through the Filter class the subscriber can easily add and remove subscribers while the publisher can easily locate subscribers relevant for a topic.


\section{Design and implementation of client}
The client in this context is the Player. The Player furthermore uses classes from the Shared project and communicates with the publish subscribe server. The Player subscribes to a specific table.

\subsection{Class diagram}

\myFigure{client_class}{Client class diagram }{fig:client_class}{1}

\section{Design and implementation of server}
The server in this context is the Dealer. The Dealer furthermore uses classes from the Shared project and communicates with the publish subscribe server.

\subsection{Class diagram}

\myFigure{server_class}{Server class diagram }{fig:server_class}{1}

\subsection{Sequence diagram}

\subsection{Implementation details}